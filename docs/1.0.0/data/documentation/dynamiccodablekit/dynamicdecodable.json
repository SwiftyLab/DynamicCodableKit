{"identifier":{"url":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable","interfaceLanguage":"swift"},"primaryContentSections":[{"declarations":[{"languages":["swift"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","text":"Decodable","preciseIdentifier":"s:Se"}],"platforms":["Linux"]}],"kind":"declarations"},{"content":[{"type":"heading","text":"Overview","anchor":"overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Provides "},{"type":"codeVoice","code":"castAs"},{"type":"text","text":" methods to customize dynamic casting to a provided type where provided type can be optional type or collection type as well. Default implementations are provided to work well with down casting, however custom types can provide their own casting behavior."}]},{"type":"paragraph","inlineContent":[{"text":"For example, in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/TypeIdentifier"},{"text":", to use ","type":"text"},{"code":"Set","type":"codeVoice"},{"text":" of ","type":"text"},{"code":"Post","type":"codeVoice"},{"text":" type instead of ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":", a box type for ","type":"text"},{"code":"Post","type":"codeVoice"},{"text":" type can be created that will confirm ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":":","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["@dynamicMemberLookup","struct AnyPost<P>: Hashable {","    let value: P","","    init(withValue value: P) {","        self.value = value","    }","","    static func == (lhs: AnyPost<P>, rhs: AnyPost<P>) -> Bool {","        lhs.value as! AnyHashable == rhs.value as! AnyHashable","    }","","    func hash(into hasher: inout Hasher) {","        (value as! AnyHashable).hash(into: &hasher)","    }","","    subscript<T>(dynamicMember path: KeyPath<P,T>) -> T {","        return value[keyPath: path]","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"and custom "},{"type":"codeVoice","code":"castAs"},{"type":"text","text":" implementation can be provided for casting to "},{"type":"codeVoice","code":"AnyPost"},{"type":"text","text":" box type:"}]},{"type":"codeListing","syntax":"swift","code":["extension DynamicDecodable where Self: Post {","    func castAs<T>(type: T.Type, codingPath: [CodingKey]) throws -> T {","        switch self {","        case let value as T:","            return value","        case _ where T.self is AnyPost<Post>.Type:","            return AnyPost(withValue: self as Post) as! T","        default:","            throw DecodingError.typeMismatch(T.self, codingPath: codingPath)","        }","    }","    func castAs<T: ExpressibleByNilLiteral>(type: T.Type, codingPath: [CodingKey]) -> T {","        return self as? T ?? AnyPost(withValue: self as Post) as? T ?? nil","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, set of posts can be decoded with following "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":" model:"}]},{"type":"codeListing","syntax":"swift","code":["struct ThrowingPostPageSet: Decodable {","    let next: URL","    @StrictDynamicDecodingCollectionWrapper<PostSetCodingKey, Set<AnyPost<Post>>> var content: Set<AnyPost<Post>>","}"]}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/dynamiccodablekit\/dynamicdecodable"]}],"kind":"symbol","topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-1mmv2","doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-4hwd","doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-84ht0"]}],"metadata":{"externalID":"s:17DynamicCodableKit0A9DecodableP","title":"DynamicDecodable","navigatorTitle":[{"kind":"identifier","text":"DynamicDecodable"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"}],"roleHeading":"Protocol","symbolKind":"protocol","role":"symbol","modules":[{"name":"DynamicCodableKit"}]},"relationshipsSections":[{"type":"inheritsFrom","title":"Inherits From","kind":"relationships","identifiers":["doc:\/\/DynamicCodableKit\/Se"]}],"schemaVersion":{"minor":2,"major":0,"patch":0},"hierarchy":{"paths":[["doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit"]]},"abstract":[{"type":"text","text":"A type that can be dynamically casted to multiple type,"},{"type":"text","text":" "},{"type":"text","text":"allowing dynamic decoding."}],"sections":[],"references":{"doc://DynamicCodableKit/documentation/DynamicCodableKit/TypeIdentifier":{"role":"collectionGroup","kind":"article","url":"\/documentation\/dynamiccodablekit\/typeidentifier","title":"Decoding with Type Identifiers","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/TypeIdentifier","type":"topic","abstract":[{"text":"Decode dynamic JSON objects based on single or multiple identifiers that indicates the actual type to decode.","type":"text"}]},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-1mmv2":{"role":"symbol","defaultImplementations":4,"identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-1mmv2","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"castAs"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"type"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":".Type, "},{"text":"codingPath","kind":"externalParam"},{"text":": [","kind":"text"},{"text":"CodingKey","preciseIdentifier":"s:s9CodingKeyP","kind":"typeIdentifier"},{"text":"]) -> ","kind":"text"},{"text":"T","kind":"typeIdentifier"}],"title":"castAs(type:codingPath:)","required":true,"abstract":[{"text":"Cast self as optional type ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" or initialize ","type":"text"},{"code":"T","type":"codeVoice"},{"text":" with ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" value.","type":"text"}],"type":"topic","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-1mmv2","kind":"symbol"},"doc://DynamicCodableKit/Se":{"type":"unresolvable","identifier":"doc:\/\/DynamicCodableKit\/Se","title":"Swift.Decodable"},"doc://DynamicCodableKit/documentation/DynamicCodableKit":{"title":"DynamicCodableKit","type":"topic","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit","abstract":[{"type":"text","text":"Access essential data types, property wrappers, and protocols to implement dynamic JSON decoding functionality working with Swiftâ€™s sound type system."}],"url":"\/documentation\/dynamiccodablekit","kind":"symbol","role":"collection"},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable":{"kind":"symbol","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable","navigatorTitle":[{"kind":"identifier","text":"DynamicDecodable"}],"type":"topic","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable","title":"DynamicDecodable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"}],"abstract":[{"type":"text","text":"A type that can be dynamically casted to multiple type,"},{"type":"text","text":" "},{"type":"text","text":"allowing dynamic decoding."}],"role":"symbol"},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-4hwd":{"abstract":[{"type":"text","text":"Cast self as generic  type "},{"type":"codeVoice","code":"T"},{"type":"text","text":"."}],"required":true,"identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-4hwd","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"castAs","kind":"identifier"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"kind":"text","text":">("},{"kind":"externalParam","text":"type"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":".Type, "},{"kind":"externalParam","text":"codingPath"},{"kind":"text","text":": ["},{"text":"CodingKey","preciseIdentifier":"s:s9CodingKeyP","kind":"typeIdentifier"},{"text":"]) ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"T","kind":"typeIdentifier"}],"role":"symbol","kind":"symbol","type":"topic","title":"castAs(type:codingPath:)","defaultImplementations":4,"url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-4hwd"},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-84ht0":{"kind":"symbol","defaultImplementations":4,"url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-84ht0","type":"topic","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-84ht0","title":"castAs(type:codingPath:)","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"castAs"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"type"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":".Type, "},{"kind":"externalParam","text":"codingPath"},{"kind":"text","text":": ["},{"kind":"typeIdentifier","text":"CodingKey","preciseIdentifier":"s:s9CodingKeyP"},{"text":"]) ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"T","kind":"typeIdentifier"}],"abstract":[{"type":"text","text":"Cast self as collection type "},{"code":"T","type":"codeVoice"},{"type":"text","text":"."}],"role":"symbol","required":true}}}