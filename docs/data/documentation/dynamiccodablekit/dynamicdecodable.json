{"sections":[],"hierarchy":{"paths":[["doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable"},"schemaVersion":{"major":0,"minor":2,"patch":0},"primaryContentSections":[{"declarations":[{"languages":["swift"],"platforms":["Linux"],"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"},{"kind":"text","text":" : "},{"kind":"typeIdentifier","text":"Decodable","preciseIdentifier":"s:Se"}]}],"kind":"declarations"},{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"overview"},{"inlineContent":[{"type":"text","text":"Provides "},{"type":"codeVoice","code":"castAs"},{"type":"text","text":" methods to customise dynamic casting to a provided type where provided type can be optional type or collection type as well. Default implementations are provided to work well with down casting, however custom types can provide their own casting behavior."}],"type":"paragraph"},{"inlineContent":[{"text":"For example, in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/TypeIdentifier","type":"reference"},{"text":", to use ","type":"text"},{"code":"Set","type":"codeVoice"},{"text":" of ","type":"text"},{"code":"Post","type":"codeVoice"},{"text":" type instead of ","type":"text"},{"code":"Array","type":"codeVoice"},{"text":", a box type for ","type":"text"},{"code":"Post","type":"codeVoice"},{"text":" type can be created that will confirm ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["@dynamicMemberLookup","struct AnyPost<P>: Hashable {","    let value: P","","    init(withValue value: P) {","        self.value = value","    }","","    static func == (lhs: AnyPost<P>, rhs: AnyPost<P>) -> Bool {","        lhs.value as! AnyHashable == rhs.value as! AnyHashable","    }","","    func hash(into hasher: inout Hasher) {","        (value as! AnyHashable).hash(into: &hasher)","    }","","    subscript<T>(dynamicMember path: KeyPath<P,T>) -> T {","        return value[keyPath: path]","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"and custom ","type":"text"},{"code":"castAs","type":"codeVoice"},{"text":" implementation can be provided for casting to ","type":"text"},{"code":"AnyPost","type":"codeVoice"},{"text":" box type:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension DynamicDecodable where Self: Post {","    func castAs<T>(type: T.Type, codingPath: [CodingKey]) throws -> T {","        switch self {","        case let value as T:","            return value","        case _ where T.self is AnyPost<Post>.Type:","            return AnyPost(withValue: self as Post) as! T","        default:","            throw DecodingError.typeMismatch(T.self, codingPath: codingPath)","        }","    }","    func castAs<T: ExpressibleByNilLiteral>(type: T.Type, codingPath: [CodingKey]) -> T {","        return self as? T ?? AnyPost(withValue: self as Post) as? T ?? nil","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"Finally, set of posts can be decoded with following ","type":"text"},{"code":"Decodable","type":"codeVoice"},{"text":" model:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct ThrowingPostPageSet: Decodable {","    let next: URL","    @StrictDynamicDecodingCollectionWrapper<PostSetCodingKey, Set<AnyPost<Post>>> var content: Set<AnyPost<Post>>","}"],"syntax":"swift"}],"kind":"content"}],"abstract":[{"text":"A type that can be dynamically casted to multiple type,","type":"text"},{"text":" ","type":"text"},{"text":"allowing dynamic decoding.","type":"text"}],"metadata":{"symbolKind":"protocol","role":"symbol","title":"DynamicDecodable","navigatorTitle":[{"kind":"identifier","text":"DynamicDecodable"}],"modules":[{"name":"DynamicCodableKit"}],"externalID":"s:17DynamicCodableKit0A9DecodableP","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"}],"roleHeading":"Protocol"},"topicSections":[{"title":"Instance Methods","identifiers":["doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-1mmv2","doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-4hwd","doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-84ht0"]}],"kind":"symbol","relationshipsSections":[{"title":"Inherits From","identifiers":["doc:\/\/DynamicCodableKit\/Se"],"kind":"relationships","type":"inheritsFrom"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/dynamiccodablekit\/dynamicdecodable"]}],"references":{"doc://DynamicCodableKit/documentation/DynamicCodableKit/TypeIdentifier":{"title":"Decoding with Type Identifiers","role":"collectionGroup","abstract":[{"text":"Decode dynamic JSON objects based on single or mutiple identifiers that indicates the actual type to decode.","type":"text"}],"type":"topic","url":"\/documentation\/dynamiccodablekit\/typeidentifier","kind":"article","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/TypeIdentifier"},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicDecodable"}],"type":"topic","role":"symbol","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable","abstract":[{"type":"text","text":"A type that can be dynamically casted to multiple type,"},{"type":"text","text":" "},{"type":"text","text":"allowing dynamic decoding."}],"title":"DynamicDecodable","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"DynamicDecodable"}]},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-4hwd":{"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"castAs"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"text":">(","kind":"text"},{"text":"type","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"T","kind":"typeIdentifier"},{"text":".Type, ","kind":"text"},{"text":"codingPath","kind":"externalParam"},{"text":": [","kind":"text"},{"preciseIdentifier":"s:s9CodingKeyP","text":"CodingKey","kind":"typeIdentifier"},{"text":"]) ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"T","kind":"typeIdentifier"}],"type":"topic","role":"symbol","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-4hwd","abstract":[{"type":"text","text":"Cast self as generic  type "},{"code":"T","type":"codeVoice"},{"type":"text","text":"."}],"title":"castAs(type:codingPath:)","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-4hwd","kind":"symbol","required":true,"defaultImplementations":4},"doc://DynamicCodableKit/Se":{"title":"Swift.Decodable","identifier":"doc:\/\/DynamicCodableKit\/Se","type":"unresolvable"},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-1mmv2":{"title":"castAs(type:codingPath:)","kind":"symbol","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-1mmv2","defaultImplementations":4,"identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-1mmv2","required":true,"role":"symbol","abstract":[{"type":"text","text":"Cast self as optional type "},{"type":"codeVoice","code":"T"},{"type":"text","text":" or initialize "},{"type":"codeVoice","code":"T"},{"type":"text","text":" with "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" value."}],"type":"topic","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"castAs"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"type"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":".Type, "},{"kind":"externalParam","text":"codingPath"},{"kind":"text","text":": ["},{"kind":"typeIdentifier","preciseIdentifier":"s:s9CodingKeyP","text":"CodingKey"},{"kind":"text","text":"]) -> "},{"kind":"typeIdentifier","text":"T"}]},"doc://DynamicCodableKit/documentation/DynamicCodableKit/DynamicDecodable/castAs(type:codingPath:)-84ht0":{"kind":"symbol","type":"topic","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit\/DynamicDecodable\/castAs(type:codingPath:)-84ht0","required":true,"title":"castAs(type:codingPath:)","url":"\/documentation\/dynamiccodablekit\/dynamicdecodable\/castas(type:codingpath:)-84ht0","defaultImplementations":4,"role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"castAs"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"T"},{"kind":"text","text":">("},{"kind":"externalParam","text":"type"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"kind":"text","text":".Type, "},{"kind":"externalParam","text":"codingPath"},{"kind":"text","text":": ["},{"kind":"typeIdentifier","text":"CodingKey","preciseIdentifier":"s:s9CodingKeyP"},{"kind":"text","text":"]) "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"T"}],"abstract":[{"text":"Cast self as collection type ","type":"text"},{"code":"T","type":"codeVoice"},{"text":".","type":"text"}]},"doc://DynamicCodableKit/documentation/DynamicCodableKit":{"title":"DynamicCodableKit","url":"\/documentation\/dynamiccodablekit","kind":"symbol","identifier":"doc:\/\/DynamicCodableKit\/documentation\/DynamicCodableKit","role":"collection","type":"topic","abstract":[{"type":"text","text":"Access essential data types, property wrappers, and protocols to implement dynamic JSON decoding functionality working with Swift’s sound type system."}]}}}